## ACID理论

*ACID 理论是对事务特性的抽象和总结，方便我们实现事务*



#### ACID

ACID 是关系型数据库的事务机制需要遵守的原则



##### 原子性(Atomicity)

一个事务的所有系列操作步骤被看成一个动作，所有的步骤要么全部完成，要么一个也不会完成。如果在事务过程中发生错误，则会回滚到事务开始前的状态，将要被改变的数据库记录不会被改变

##### 一致性(Consistency)

一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏，即数据库事务不能破坏关系数据的完整性及业务逻辑上的一致性

##### 隔离性(Isolation)

主要用于实现并发控制，隔离能够确保并发执行的事务按顺序一个接一个地执行。通过隔离，一个未完成事务不会影响另外一个未完成事务。

##### 持久性(Durability)

一旦一个事务被提交，它应该持久保存，不会因为与其他操作冲突而取消这个事务



#### 分布式事务协议

*ACID实现方式*

##### 2PC(二阶段提交协议)

通过二阶段的协商来完成一个提交操作

- 提交请求阶段（又称投票阶段）
- 提交执行阶段（又称完成阶段）

*需要注意的是，在第一个阶段，每个参与者投票表决事务是放弃还是提交。一旦参与者投票要求提交事务，那么就不允许放弃事务。*

*还需要你注意的是，在第二个阶段，事务的每个参与者执行最终统一的决定，提交事务或者放弃事务*

**存在的问题:**

- 在提交请求阶段，需要预留资源，在资源预留期间，其他人不能操作
- 数据库是独立的系统

***我们无法根据业务特点弹性地调整锁的粒度，而这些都会影响数据库的并发性能***

##### TCC(Try-Confirm-Cancel)

TCC 是 Try（预留）、Confirm（确认）、Cancel（撤销） 3 个操作的简称，它包含了预留、确认或撤销这 2 个阶段。**TCC 本质上是补偿事务**。它是一个业务层面的协议，其 3 个操作是需要在业务代码中编码实现的，为了实现一致性，确认操作和补偿操作必须是等幂的，因为这 2 个操作可能会失败重试。

**优势:**

- 不依赖于数据库的事务，能减轻数据库的压力

**问题:**

- 业务代码的入侵性也更强，实现的复杂度也更高

##### 三阶段提交协议

针对二阶段提交协议的**“协调者故障，参与者长期锁定资源”**的痛点，通过引入了**询问阶段和超时机制**，来减少资源被长时间锁定的情况，不过这会导致集群各节点**在正常运行的情况下，使用更多的消息进行协商，增加系统负载和响应延迟**。也正是因为这些问题，三阶段提交协议很少被使用



##### 2PC和TCC差异

1. 实现位置不同，前者在数据服务中实现，而后者在业务中实现，后者更加自由，可以控制锁的粒度，减轻数据服务压力，但实现复杂，代码入侵性强
2. 前者是强一致性的，在集群间一致性数据同步，所有参与者完成的是同一件事，后者是最终一致性的，对业务进行拆分
3. 前者服务中的某个节点作为协调者，后者则是客户端作为协调者



#### 小结

- 二阶段提交协议，不仅仅是协议，也是一种非常经典的思想。二阶段提交在达成提交操作共识的算法中应用广泛，比如 XA 协议、TCC、Paxos、Raft 等。我希望你不仅能理解二阶段提交协议，更能理解协议背后的二阶段提交的思想，当后续需要时，能灵活地根据二阶段提交思想，设计新的事务或一致性协议。
- 幂等性，是指同一操作对同一系统的任意多次执行，所产生的影响均与一次执行的影响相同，不会因为多次执行而产生副作用。常见的实现方法有 Token、索引等。它的本质是通过唯一标识，标记同一操作的方式，来消除多次执行的副作用。
- 可以将 ACID 特性理解为 CAP 中一致性的边界，最强的一致性，也就是 CAP 的酸（Acid）。根据 CAP 理论，如果在分布式系统中实现了一致性，可用性必然受到影响。比如，如果出现一个节点故障，则整个分布式事务的执行都是失败的。实际上，**绝大部分场景对一致性要求没那么高**，短暂的不一致是能接受的，另外，也**基于可用性和并发性能的考虑，建议在开发实现分布式系统，如果不是必须，尽量不要实现事务，可以考虑采用最终一致性**



#### 思考

Q: 事务型分布式系统有哪些优点，哪些缺点呢？

A: 既然说的是事务型分布式事务，首先要关注到分布式关键字，最好的事务控制永远是单机模式，但是问题是对于并发特别高的系统来说，读写的压力都会增加，系统可用性降低，会出现延迟不可访问等问题，所以将一些写入频繁的功能从系统中剥离出来，横向扩展，降低系统压力，提高可用性。由此而带来了新的问题，事务。通过文中叙述的协议解决分布式事务问题的数据不一致性，但是因为是分阶段的确认提交，在确认提交的过程中，增加了数据库记录锁的时间，对于用户私有数据来说，这影响不大，对于公有数据而言，分布式事务和单机事务区别不大，都需要排队等待。如果牺牲一致性，选择分区容错性，允许节点数据短暂不一致，提高了系统可用性，但是数据库之间的主从关系，复制备份等问题又随之而来，又将问题进一步扩大和转移。总之，当性能还说的过去的前提下，尽量不要向分布式发展。一入此门深似海

R: 系统设计是根据实际场景权衡折中的结果，需要妥协，架构越简单越好。将简单问题复杂化、为了技术而技术，是在工作中，需要极力避免的。曾经历一个产品，技术和架构，在理论是无懈可击、极其先进，但实现复杂度极高，迭代多个版本，耗时多年，始终无法稳定落地，而且维护工作量极其大，最终产品没落，丧失了十几亿美刀的市场

---

Q: 在两阶段提交协议中，如果一个节点在第一阶段确认可以提交，然后崩溃了怎么办？第二阶段它实际没法真正应用自己那部分事务，该如何处理？

A: 需要将提交相关信息保存到持久存储上，新进程启动后，恢复到之前的状态

---

Q: Raft和2PC适用场景一样吗?

A: 并不一样，虽然对数据来说都是强一致性。处理一个订单，需要执行A、B、C三个操作，二阶段提交协议，能保证3个操作要么全部执行，要么全部不执行。而Raft能做到，你执行了A操作后，你就一致能读到A操作执行后的结果（2PC解决的是分布式事务问题，而raft 这些解决的是分布式数据共识问题）

---

Q: 如果一个transaction的rollback失败了，应该怎么办？

A: 可以考虑这几种方式或根据场景特点结合起来使用，1. 直接重试；2. 触发告警，然后人工根据日志记录进行修复；3. 设计异步回滚流程，也就是说在一个异步流程中对账、回滚，避免因重试耗时而拖慢整体性能

---

Q: raft的leader在收到集群内一半以上的数据节点确认操作后就认为事务完成，这时有些节点的数据并没有更新完成，此时理解应该为最终一致性，为什么说raft是强一致性呢？raft强一致性难道仅仅体现在所有请求的处理都是在leader节点处理吗？

A: 强一致性，是指基于Raft能实现线性一致性，线性一致性通常被称为强一致性。你提到的这个情况是存在的，“大多数”原则导致的。可以这么理解，Raft是共识算法，Raft自身的数据是最终一致的（大多数原则决定的），但是基于Raft（加上客户端协议），我们能实现强一致性系统，比如强一致性KV存储系统。而我们通常说，**Raft是强一致性，其实指的是，我们基于Raft这个算法实现的系统是强一致性的**

