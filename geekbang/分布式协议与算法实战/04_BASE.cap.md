## BASE理论

*BASE 理论是针对 [NoSQL](http://c.biancheng.net/nosql/) 数据库而言的，它是对 [CAP](http://c.biancheng.net/view/6493.html) 理论中一致性（C）和可用性（A）进行权衡的结果，源于提出者自己在大规模分布式系统上实践的总结。**其核心思想是无法做到强一致性，但每个应用都可以根据自身的特点，采用适当方式达到最终一致性**。*

#### BASE

- 基本可用(Basically Available)

  基本可用指分布式系统在出现故障时，系统允许损失部分可用性，即保证核心功能或者当前最重要功能可用。

  对于用户来说，他们当前最关注的功能或者最常用的功能的可用性将会获得保证，但是其他功能会被削弱。

- 软状态(Soft-state)

  软状态允许系统数据存在中间状态，但不会影响系统的整体可用性，即允许不同节点的副本之间存在暂时的不一致情况。

- 最终一致性(Eventually Consistent)

  最终一致性要求系统中数据副本最终能够一致，而不需要实时保证数据副本一致

  **最终一致性可以分为客户端和服务端两个不同的视角**:

  ###### 从客户端的角度看

  从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题，最终一致性有以下 5 个变种。

  | 一致性变种                            | 说明                                                         |
  | ------------------------------------- | ------------------------------------------------------------ |
  | 因果一致性                            | 如果进程 A 通知进程 B 它已更新了一个数据项，那么，进程 B 的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程 A 无因果关系的进程 C 的访问遵守一般的最终一致性规则。 |
  | 读己之所写（Read-Your-Writes） 一致性 | 当进程 A 自己更新一个数据项之后，它总是访问到更新过的值，且不会看到旧值。这是因果一致性模型的一个特例。 |
  | 会话（Session）—致性                  | 这是上一个模型的实用版本，它把访问存储系统的进程放到会话的上下文中。只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统保证不会延续到新的会话。 |
  | 单调（Monotonic）读一致性             | 如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。 |
  | 单调写一致性                          | 系统保证来自同一个进程的写操作顺序执行。                     |


  上述最终一致性的不同方式可以进行组合，例如，单调读一致性和“读己之所写”一致性就可以组合实现。从实践的角度来看，这两者的组合读取自己更新的数据，一旦读取到最新的版本，就不会再读取旧版本，对基于此架构上的程序开发来说，会减少很多额外的烦恼。

  ###### 从服务器的角度看

  从服务端来看，如何尽快地将更新后的数据分布到整个系统，**降低达到最终一致性的时间窗口**，是提高系统的可用度和用户体验度非常重要的方面。

  分布式数据系统有以下特性：

  - N 为数据复制的份数。
  - W 为更新数据时需要进行写操作的节点数。
  - R 为读取数据的时候需要读取的节点数。


  如果 W+R>N，写的节点和读的节点重叠，则是强一致性。例如，对于典型的一主一备同步复制的关系型数据库（N=2, W=2,R=1），则不管读的是主库还是备库的数据，都是一致的。

  如果 W+R≤N，则是弱一致性。例如，对于一主一备异步复制的关系型数据库（N=2,W=1,R=1），如果读的是备库，则可能无法读取主库已经更新过的数据，所以是弱一致性。

  对于分布式系统，为了保证高可用性，一般设置 N≥3。设置不同的N、W、R 组合，是在可用性和一致性之间取一个平衡，以适应不同的应用场景。

  如果N=W 且 R=1，则任何一个写节点失效，都会导致写失败，因此可用性会降低。但是由于数据分布的 N 个节点是同步写入的，因此可以保证强一致性。

  如果 N=R 且 W=1，则只需要一个节点写入成功即可，写性能和可用性都比较高。但是读取其他节点的进程可能不能获取更新后的数据，因此是弱一致性。在这种情况下，如果 W＜(N+1)/2，并且写入的节点不重叠，则会存在写冲突。

#### 实现基本可用的4板斧

- 流量削峰
- 延迟响应
- 体验降级
- 过载保护

#### 实现最终一致性

##### 思路

- 以最新写入的数据为准，比如 AP 模型的 KV 存储采用的就是这种方式；
- 以第一次写入的数据为准，如果你不希望存储的数据被更改，可以以它为准

##### 方式

- 读时修复：在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。
- 写时修复：在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败就将数据缓存下来，然后定时重传，修复数据的不一致性。
- 异步修复：这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复（反熵）。

##### 对比

写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，所以我推荐你在实现最终一致性时优先实现这种方式。而读时修复和异步修复因为需要做数据的一致性对比，性能消耗比较多，在开发实际系统时，你要尽量优化一致性对比的算法，降低性能消耗，避免对系统运行造成影响